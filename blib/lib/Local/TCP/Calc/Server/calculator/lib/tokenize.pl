=head1 DESCRIPTION

Эта функция должна принять на вход арифметическое выражение,
а на выходе дать ссылку на массив, состоящий из отдельных токенов.
Токен - это отдельная логическая часть выражения: число, скобка или арифметическая операция
В случае ошибки в выражении функция должна вызывать die с сообщением об ошибке

Знаки '-' и '+' в первой позиции, или после другой арифметической операции стоит воспринимать
как унарные и можно записывать как "U-" и "U+"

Стоит заметить, что после унарного оператора нельзя использовать бинарные операторы
Например последовательность 1 + - / 2 невалидна. Бинарный оператор / идёт после использования унарного "-"

=cut

use 5.010;
use strict;
use warnings;
use diagnostics;
BEGIN{
	if ($] < 5.018) {
		package experimental;
		use warnings::register;
	}
}
no warnings 'experimental';

sub tokenize {
	chomp(my $str = shift);	
	my @res;
	my $u='U';
	my $n=0;
	my $all="";
	my $offset=1;
	$str =~ s/[ ]+//g;																# удаление пробелов
	if ($str =~ /(\d+)\.(\d+)\.(\d+)/)
	{
		die "error. you put not a number\n";
	}	
	if ($str =~ /[a-df-zA-DF-Z]/)
	{
		die "error. you put a letter\n";
	}
	if ($str =~ /[:;#№\"\'@!\?_=&~|\\\}\{]/)
	{
		die "error. an incorrect character in the expression\n";
	}
	if ($str =~ /[\+\-\*\/%\^\.\,\(e]$/)
	{
		die "error. an incorrect character at the end of the expression\n";
	}
	if ($str =~ /^[\*\/\%\^\)]/)
	{
		die "error. an incorrect character at the begin of the expression\n";
	}
	if ($str =~ /ee+/)
	{
		die "error. more then one 'e'\n";
	}
	$str =~ s/(\D|^)(\.\d*)/$1.$n.$2/eg;				 							# дробное число дополнится до норального вида (.5 исправится до 0.5)
	$str =~ s/(\d+)\.$n/$1/eg;														# целое число сократится до норального вида (9.0 исправится до 9)
	$str =~ s/(\d*\.*\d*)e(.?\d+)/$1*10**$2;/eg;									# преобразование из экспоненциальной записи	
	$str =~ s/(^)([+-])/$1$u$2/g;													# поставится унарный минус в начале строки , если он есть
	$str =~ s/([\*\^\+\-\/\(])([\+-])(.)/$1$u$2$3/g;								# унарный минус/плюс (в случаях, когда он после других операций)
	$str =~ s/(U-)([\+-])(.)/$1$u$2$3/g;											# унарный минус
	$str =~ s/(U\+)([\+-])(.)/$1$u$2$3/g;											# унарный плюс
	$str =~ s/([*\/])([+-][\(])/$1$u$2/g;											# унарные плюс/минус перед скобкой
	@res = split /(?:(U\+)|(U\-)|(\*)|(\/)|(\^)|(\%)|(\()|(\))|(\-)|(\+))/,$str;    # деление массива по всем арифметическим знакам
	for(my $i = 0;$i <= $#res;$i++ )
	{	
		if (!defined($res[$i]))													    # удаление элемента из массива если он undef
		{
			splice(@res,$i,$offset);
			$i--;
		}
		elsif(($res[$i])=~/^\s*$/)													# или пустая строка
		{
			splice(@res,$i,$offset);
			$i--;
		}
		else{
		}
	}
	return \@res;
}

1;

